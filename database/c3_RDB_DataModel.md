# Chapter 3 관계 데이터 모델과 제약조건

## 관계 데이터 모델의 구성 요소

### 데이터 모델 (data model)

- 현실 세계의 데이터를 명세하는 고유한 표현 방식 - 데이터 모델링을 위한 도구
- 데이터 구조와 연산, 제약조건 3가지 요소로 구성

![스크린샷 2021-09-22 오후 8 11 14](https://user-images.githubusercontent.com/70752848/134333574-122315ef-d806-4e2a-9844-1f2afecc8786.png)

### 관계형 데이터 모델

- 관계형 데이터 모델은 데이터를 2차원 테이블 형태인 **릴레이션**으로 표현
- 릴레이션에 대한 제약조건(constraints)과 관계 연산을 위한 관계대수(relational algebra)를 정의

![스크린샷 2021-09-22 오후 8 14 17](https://user-images.githubusercontent.com/70752848/134333828-f4bb3014-0ef7-4ed6-a1ea-d5131677d838.png)

## 관계 데이터 모델의 개념

### 릴레이션

- 릴레이션(Relation)
  - 2차원 테이블(행과 열로 구성된 테이블)
- 속성, 애트리뷰트(Attribute)
  - 테이블의 열(Column)
  - 속성 이름을 보면 어떤 종류의 데이터 값이 저장되는지 그 의미를 알 수 있음
- 투플(Tuple)
  - 테이블의 행(Row)
  - 각 속성 값들의 조합으로 구성

![스크린샷 2021-09-22 오후 8 16 46](https://user-images.githubusercontent.com/70752848/134334145-0e39be6c-f7f3-4579-8fc3-1219f0113883.png)

![스크린샷 2021-09-22 오후 8 21 49](https://user-images.githubusercontent.com/70752848/134334889-c195bb55-f960-4182-8d2b-098095934c5b.png)

## 도메인

### 도메인(Domain)

- 한 애트리뷰트에 나타낼 수 있는 값들의 집합
- 각 애트리뷰트의 도메인의 값들은 원자의 값
- 프로그래밍 언어의 데이터 타입과 유사함
- 동일한 도메인이 여러 애트리뷰트에서 사용될 수 있음

## 차수와 카디날리티

### 차수(Degree)

- 한 릴레이이션에 들어 있는 애트리뷰트들의 수
  - 유효한 릴레이션의 최소 차수는 1
  - 릴레이션의 차수는 자주 바뀌지 않음(정적 특성)

### 카디날리티(Cardinality)

- 릴레이션의 투플 수
  - 유효한 릴레이션은 카디날리티 0을 가질 수 있음
  - 릴레이션의 카디날리티는 입력, 수정, 삭제 등을 통해 계속 변함(동적 특성)

![스크린샷 2021-09-22 오후 8 21 11](https://user-images.githubusercontent.com/70752848/134334795-5e76a3c2-8c4f-47d2-9eb7-b4f6bbdf59b9.png)

## 널(NULL)

### 널값(null)

- "알려지지 않음" 또는 "적용할 수 없음"을 나타내기 위한 값  
  예) 사원 릴레이션에 새로운 사원에 관한 투플을 입력하는데, 신입 사원의 DNO(부서번호)가 결정되지 않았을 수 있음
- 널값은 숫자 도메인의 0이나 문자열 도메인의 공백 문자 또는 공백 문자열과 다름
- DBMS들마다 널값을 나타내기 위해 서로 다른 기호를 사용함

## 스키마와 인스턴스

### 릴레이션 스키마(relation schema)

- 릴레이션의 이름과 애트리뷰트들의 집합
  - 릴레이션 이름(애트리뷰트 이름1, 애트리뷰트 이름2, ..., 애트리뷰트 이름N)
- 기본 키 애트리뷰트에는 밑줄 표시
- 내포(intension)라고 함

### 릴레이션 인스턴스(relation instanse)

- 릴레이션에 어느 시점에 들어 있는 투플들의 집합
- 시간의 흐름에 따라 계속 변함
- 일반적으로 릴레이션에 현재의 인스턴스만 저장
- 외연(extension)이라고 함

![스크린샷 2021-09-22 오후 8 27 19](https://user-images.githubusercontent.com/70752848/134335560-73e99c7e-d4f2-44c3-ba57-ead383d96f10.png)

### 관계 데이터베이스 스키마

- 하나이상의 릴레이션 스키마들로 이루어짐

![스크린샷 2021-09-22 오후 8 28 10](https://user-images.githubusercontent.com/70752848/134335668-13bee491-f78f-4df3-9265-336996256ded.png)

### 관계 데이터베이스 인스턴스

- 릴레이션 인스턴스드르이 모임으로 구성됨

![스크린샷 2021-09-22 오후 8 28 48](https://user-images.githubusercontent.com/70752848/134335749-3cee21ea-8e96-4a02-a4c4-0759f522ebac.png)

## 데이터베이스

### 데이터 베이스 구성의 예

![스크린샷 2021-09-22 오후 8 29 34](https://user-images.githubusercontent.com/70752848/134335833-b59310d0-888a-46e6-8a28-917f6c3ebe9f.png)

## 릴레이션의 특성

### 투플의 유일성(uniqueness of tuple)

- 동일한 투플이 두 개 이상 존재하지 않음(키가 존재함)
- 하나의 릴레이션은 투플들의 집합이기 때문에 모든 투플은 서로 달라야 함

![스크린샷 2021-09-22 오후 8 31 11](https://user-images.githubusercontent.com/70752848/134336026-06604f1e-ce14-456c-b441-2d34f70fa046.png)

### 애트리뷰트의 무순서성(no ordering of attribute)

- 릴레이션의 애트리뷰트 사이에 순서는 의미가 없음
- 속성 값은 애트리뷰트의 순서가 아닌 속성 이름에 의해 참조됨

![스크린샷 2021-09-22 오후 8 32 31](https://user-images.githubusercontent.com/70752848/134336199-a698c01a-d3fd-4127-8378-2ed29db68b3c.png)

### 투플의 무순서성(no ordering of tuple)

- 릴레이션의 투플 사이에 순서는 의미가 없음
- 집합은 포함한 원소들 사이에 순서가 없음
- 투플의 집합인 릴레이션 역시 투플 사이에 순서를 갖지 않음

![스크린샷 2021-09-22 오후 8 33 56](https://user-images.githubusercontent.com/70752848/134336390-928a6ea9-7510-448d-a4c5-80600581ae8a.png)

### 애트리뷰트의 원자성(atomicity of attribute)

- 릴레이션을 구성하는 모든 애트리뷰트 값은 의미적으로 더 이상 분해할 수 없는 하나의 원자 값만을 갖음
- 각 애트리뷰트 값으로 의미적으로 더 쪼개서 사용할 수 있는 값이나 여러 개의 값이 허용되지 않음
- 릴레이션은 다중 값 속성이나 복합 애트리뷰트를 허용하지 않음

![스크린샷 2021-09-22 오후 8 35 51](https://user-images.githubusercontent.com/70752848/134336590-7b2f71bd-531a-45fe-9d9c-e54c9fbf054a.png)

### 애트리뷰트는 서로 다른 이름을 가짐

- 한 릴레이션에서 서로 다른 이름을 가져야 함

### 애트리뷰트의 내의 값들은 모두 같은 유형

- 한 애트리뷰트에 속한 열은 모두 그 애트리뷰트에서 정의한 도메인 값만 가질 수 있음

## 릴레이션의 키

### 릴레이션의 키(Key)

- 각 투플을 고유하게 **식별**할 수 있는 하나 이상의 애트리뷰트들의 모임
- 릴레이션은 중복된 투플을 허용하지 않기 때문에 각각의 투플에 포함된 애트리뷰트들 중 어느 하나(혹은 하나 이상)는 값이 달라야 함
- 키가 되는 애트리뷰트(혹은 애트리뷰트 집합)은 반드시 값이 달라서 투플들을 서로 구별 가능해야 함
- 키의 특성
  - 유일성(uniqueness): 하나의 릴레이션에서 모든 투플은 서로 다른 키 값을 가져야함
  - 최소성(minimality): 꼭 필요한 최소한의 속성들로만 키를 구성

## 키의 종류

### 수퍼 키

- 한 릴레이션 내의 특정 투플을 고유하게 식별하는 하나의 애트리뷰트 또는 그 집합
  - 예) 신용카드 회사의 고객 릴레이션에서 (신용카드번호, 주소) (주민등록번호, 이름) 또는 (주민등록번호)

| 신용카드번호 | 주민등록번호 | 이름 | 주소 | 직업 |
| ------------ | ------------ | ---- | ---- | ---- |

- 투플을 교유하게 식별하는데 꼭 필요하지 않은 애트리뷰트들을 포함 가능
  - (**신용카드번호**, 주소)
  - (**주민등록번호**, 이름)

### 후보 키

- 각 투플을 고유하게 식별하는 최소한의 애트리뷰트들의 모임
  - 예) (신용카드번호, 주소)는 신용카드 회사의 고객 릴레이션의 후보 키가 아니지만 (신용카드번호)는 후보 키
- 모든 릴레이션에는 최소한 한개 이상의 후보 키가 있음
- 후보 키도 두 개 이상의 애트리뷰트로 이루어질 수 있으며 이런 경우에 복합 키(composite key)라고 부름
  - 예) (학번, 과목 번호)가 후보 키

| 학번  | 과목 번호 | 학점 |
| ----- | --------- | ---- |
| 11002 | CS310     | A0   |
| 11002 | CS313     | B+   |
| 24036 | CS345     | B0   |
| 24036 | CS310     | A+   |

### 기본 키 (Primary Key, PK)

- 후보 키가 2개 이상이면, 설계자 또는 관리자가 이들 중에 하나를 기본 키로 선정
- 자연스러운 기본 키를 찾기 어려운 경우 인위적인 대리 키를 선정 가능

#### 고려사항

- 릴레이션 내 투플을 식별할 수 있는 고유한 값을 가져야 함
- NULL 값은 허용하지 않음
- 키 값의 변동이 일어나지 않아야 함
- 최대한 적은 수의 속성을 가진 것이어야 함
- 향후 키를 사용하는 데 있어 문제 발생 소지가 없어야 함

### 대체 키

> 기본 키가 아닌 후보 키

![스크린샷 2021-09-22 오후 10 18 34](https://user-images.githubusercontent.com/70752848/134350871-e0a69625-dd5d-4a8d-afdd-96a43fec9516.png)

### 외래 키 (Foreign Key, FK)

- 어떤 릴레이션의 기본키를 참조하는 애트리뷰트
- 관계 DB에서 릴레이션 간의 관계를 나타냄
- FK는 참조되는 릴레이션 PK와 동일한 도메인을 가짐
- 자신이 속한 릴레이션의 PK의 구성요소가 되거나 되지 않을 수 있음

#### 외래 키의 유형

![스크린샷 2021-09-22 오후 10 20 56](https://user-images.githubusercontent.com/70752848/134351259-f934a0c8-97bf-4238-ae2a-5260b2ee1668.png)

- 다른 릴레이션의 기본 키를 **참조**하는 외래 키

![스크린샷 2021-09-22 오후 10 22 06](https://user-images.githubusercontent.com/70752848/134351487-46199af3-4700-41d0-92ab-6bcfaf957934.png)

- 자체 릴레이션의 기본 키를 참조하는 외래 키

![스크린샷 2021-09-22 오후 10 24 01](https://user-images.githubusercontent.com/70752848/134351813-3ca850f9-0e32-4b68-a0c4-f19a8e665d23.png)

- 기본 키의 구성요소가 되는 외래 키

![스크린샷 2021-09-22 오후 10 25 12](https://user-images.githubusercontent.com/70752848/134351997-7d52ba16-5b99-49bf-9bd1-b383255cdd60.png)

## 키의 특성과 종류

### 특성

- 유일성: 한 릴레이션에서 모든 투플은 서로 다른 키 값을 가져야 함
- 최소성: 꼭 필요한 최소한의 속성들로만 키를 구성

### 종류

- 수퍼키: 유일성을 만족하는 속성 또는 속성들의 집합
- 후보키: 유일성과 최소성을 만족하는 속성 또는 속성들의 집합
- 기본키: 후보키 중에서 기본적으로 사용하기 위해 선택한 키
- 대체키: 기본키로 선택되지 못한 후보키
- 외래키: 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합

## 무결성 제약조건

### 데이터 무결성(data integrity)

> 데이터의 정확성 또는 유효성을 의미

### 무결성 제약조건

> 관계 데이터 모델에서 릴레이션 안의 모든 데이터들을 결함없이 항상 정확하고 완전한 상태로 유지하기 위해 적용해야 할 제약 사항

### 데이터 베이스가 갱신될 때 DBMS가 자동적으로 일관성 조건을 검사하므로 응용 프로그램들은 일관성 조건을 검사할 필요가 없음

### 도메인 제약조건(domain constraint)

- 각 애트리뷰트 값이 반드시 원자 값이어야 함
- 애트리뷰트 값의 디폴트 값, 가능한 값들의 범위 등을 지정할 수 있음
- 데이터 형식을 통해 값들의 유형을 제한하고, CHECK 제약 조건을 통해 값들의 범위를 제한 가능

### 키 제약조건(key constraint)

- 키 애트리뷰트에 중복된 값이 존재해서는 안됨

#### 기본 키와 엔티티 무결성 제약조건(개체 무결성 제약조건, entity integrity constraint)

- 릴레이션의 기본 키를 구성하는 어떤 애트리뷰트도 널값을 가질 수 없음
- 대체 키에는 적용되지 않음
- 사용자는 릴레이션을 생성하는 데이터 정의문에서 어떤 애트리뷰트가 릴레이션의 기본키의 구성요소인가를 DBMS에 알려줌

![스크린샷 2021-09-22 오후 10 34 01](https://user-images.githubusercontent.com/70752848/134353488-ccc27bb5-ef1f-4f92-9305-8a01ba77049d.png)

#### 외래 키와 참조 무결성 제약조건(참조 무결성 제약 조건, referential integrity constraint)

- 참조 무결성 제약조건은 두 릴레이션의 연관된 투플들 사이의 일관성을 유지하는데 사용됨
- 관계 DB가 릴레이션들로만 이루어지고, 릴레이션 사이의 관계들이 다른 릴레이션의 기본 키를 참조하는 것을 기반으로 하여 묵시적으로 표현되기 때문에 외래 키의 개념이 중요
- 릴레이션 R2의 외래 키가 릴레이션 R1의 기본 키를 참조할 때 참조 무결성 제약조건은 아래 두 조건 중 하나가 성립되면 만족함
  - 외래 키의 값은 R1의 어떤 투플의 기본 키 값과 같다
  - 외래 키가 자신을 포함하고 있는 릴레이션의 기본키를 구성하고 있지 않으면 널 값을 가진다

![스크린샷 2021-09-22 오후 10 38 17](https://user-images.githubusercontent.com/70752848/134354200-d791588e-31c1-423f-9b2a-4689586dac1a.png)
